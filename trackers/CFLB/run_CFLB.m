function results = run_CFLB(seq, res_path, bSaveImage)

%   -----------------------------------------------------------
%   Add the pathes of functions and filters
addpath('Helper Functions/');
% addpath ('../../benchmarks/');
addpath ('CFwLB/');

% iteration = [ 1 2 4 8 16 32 64];
iteration = 2;

videoInd = 1;

minItr = 1;
maxItr = 1;
% the portion of frame that I used to train the smaller filter
padding = 2 ;

% Etha is the updating factor at each frame. refer to the paper
% etha = [0.025 0.05 0.075 0.1 .125];
% 
output_sigma_factor = 1/16;

% initial the tracker at the first frame using 
% 8 images are generated by small rotation, scaling, transaction. 
ini_im = 1;

v = 1; % demo for david tracking.
% The etha values are borrowd from other papers for the videos
etha = .025;  

vis = 0; % to visualize the response and filter
Visfilt = 0; % to visualize training process of the filter
visTracking = 0;

target_sz = seq.init_rect(1,[4,3]);
pos = seq.init_rect(1,[2,1]) + floor(target_sz/2);
img_files = seq.s_frames;
video_path = [];
ground_truth = seq.init_rect;
if sqrt(prod(target_sz)) >= 50 && sqrt(prod(target_sz))<100
	pos = floor(pos / 2);
	target_sz = floor(target_sz / 2);
	resize_image = true;
    resize_scale = 2;
elseif sqrt(prod(target_sz))>=100
    pos = floor(pos / 4);
    target_sz = floor(target_sz / 4);
    resize_image = true;
    resize_scale = 4;

else
    resize_image = false;
    resize_scale = 0;
end

%window size, taking padding into account
s_filt_size = floor(target_sz ); % the size of small filter
b_filt_size = floor(target_sz * (1 + padding)); % the size of big filter
output_sigma = sqrt(prod(s_filt_size)) * output_sigma_factor;
% output_sigma = 1;

%desired output (gaussian shaped), bandwidth proportional to target size
sz = b_filt_size;
[rs, cs] = ndgrid((1:sz(1)) - floor(sz(1)/2), (1:sz(2)) - floor(sz(2)/2));
y = exp(-0.5 / output_sigma^2 * (rs.^2 + cs.^2));
y = circshift(y, fix(s_filt_size/2));
yf = fftvec(y(:), b_filt_size);

if resize_image,
    ground_truth = fix(ground_truth/resize_scale);
end;

% dump variables
positions = zeros(numel(img_files), 2);  %to calculate precision
psr = zeros(numel(img_files), 1);  %to calculate precision
runTime = zeros(numel(img_files), 1);  %to calculate precision
MMx = prod(b_filt_size);
ZX = zeros(MMx, 1);
ZZ = zeros(MMx, 1);
term = 1e-6;

% hfig = figure;
for frame = 1:numel(img_files)
    df = zeros(prod(b_filt_size), 1);
    sf = zeros(prod(b_filt_size), 1);
    Ldsf  = zeros(prod(b_filt_size), 1);
  
%     im = imread([video_path '/img/' img_files(frame).name]);
    im = imread([video_path img_files{frame}]);
    imcolor = im;
    if size(im,3) > 1,
        im = rgb2gray(im);
    end
    if resize_image,
        im = imresize(im, 1/resize_scale);
        imcolor = imresize(imcolor,1/resize_scale);
    end

    %extract and pre-process subwindow
    if frame == 1,  %first frame, train with random image

        [ypos xpos x] = get_subwindow(im, pos , b_filt_size);
        if ini_im
            ini_imgs = get_ini_perturbation(x, 8);
        else  
            ini_imgs = x(:);
        end;

        ECFimageF = fftvec(ini_imgs, b_filt_size);

        for n = 1:size(ini_imgs, 2)
            ZX = ZX + bsxfun(@times, conj(ECFimageF(:,n)), yf);
            ZZ = ZZ + bsxfun(@times, conj(ECFimageF(:,n)), ECFimageF(:,n));
        end

        positions(frame,:)=pos;
        runTime(frame) = 0;

    else
        startTime = tic ;
        [df, sf, Ldsf, mu] = ECF(yf, b_filt_size, 1, s_filt_size, term, minItr, maxItr, sf, df, Ldsf,ZZ,ZX, Visfilt);
        [ypos xpos cropIm] = get_subwindow(im, pos , b_filt_size);
        [rsp posRsp] = get_rsp((double(cropIm)), df, s_filt_size, b_filt_size); %gcf

%         rspTmp = rsp(posRsp(1)-floor(s_filt_size(1)/2):posRsp(1)+floor(s_filt_size(1)/2), ...
%             posRsp(2)-floor(s_filt_size(2)/2):posRsp(2)+floor(s_filt_size(2)/2));
% 
%         imTmp = cropIm(posRsp(1)-floor(s_filt_size(1)/2):posRsp(1)+floor(s_filt_size(1)/2), ...
%             posRsp(2)-floor(s_filt_size(2)/2):posRsp(2)+floor(s_filt_size(2)/2));

        [row, col] = find(rsp == max(rsp(:)), 1);
        pos = pos - floor(b_filt_size/2) + [row, col];

%         if resize_image
%             dis= sqrt(sum((pos*resize_scale - ground_truth(frame,:)*resize_scale).^2));
%         else
%             dis= sqrt(sum((pos - ground_truth(frame,:)).^2));
%         end;
        positions(frame,:)=pos;

        [yt xt x] = get_subwindow(im, pos , b_filt_size);
        xf = fftvec(x(:), b_filt_size);
        ZX = ((1-etha) * ZX) + (etha *  conj(xf) .* yf);
        ZZ = ((1-etha) * ZZ) + (etha * conj(xf) .* xf);
        endTime = toc(startTime);
        runTime(frame) = endTime;

    end;

end;
%% end of algo, saving the results
if resize_image
    positions = positions * resize_scale;
    target_sz = resize_scale*target_sz;
    ground_truth = resize_scale * ground_truth;
end;
% clipName = clips{videoInd};
% 
% posDis = sqrt(sum((positions(1:frame,:)-ground_truth(1:frame,:)).^2,2));
% 
% errMore20 = sum(posDis>20);
% accAt20 = (frame-errMore20)/frame
% avgError = sum(posDis)/frame
%  
fps = frame/sum(runTime)

rects = [positions(:,2) - target_sz(2)/2, positions(:,1) - target_sz(1)/2];
rects(:,3) = target_sz(2);
rects(:,4) = target_sz(1);
results.type = 'rect';
results.res = rects;%each row is a rectangle
results.fps = fps;
% save(['tracking1_64\' clips{videoInd} '_Itr_' num2str(maxItr) '_pad_' num2str(padding) '_etha_' num2str(etha) '.mat' ], ...
%     'positions', 'ground_truth', 'etha', 'padding' , 'maxItr', 'psr', 'runTime', 'clipName', 'frame', 'target_sz', 'ini_im', 'accAt20', 'avgError','fps');
% 1+1
end